// This file is auto-generated by the build script.
// Do not edit manually - changes will be overwritten.

export interface Example {
  id: string;
  name: string;
  source: string;
}

export const EXAMPLES: Example[] = [
  {
    id: "welcome",
    name: "Welcome",
    source: `# Welcome to Cadenza!
# A functional language with units of measure

# Try some basic expressions
42
3.14159
1 + 2 * 3

# Define variables
let name = "Cadenza"
let version = 0.1

# Create functions
fn square x = x * x
square 5
`,
  },
  {
    id: "literals",
    name: "Literals",
    source: `# Literal Values
# Different types of literals

# Integers
42
-17
0

# Floating point
3.14159
-2.5
1.0

# Strings
"hello"
"world"
"hello world"
`,
  },
  {
    id: "arithmetic",
    name: "Arithmetic",
    source: `# Arithmetic Operations
# Basic math with integers and floats

# Addition and subtraction
1 + 2
10 - 3

# Multiplication and division
4 * 5
20 / 4

# Operator precedence
2 + 3 * 4
(2 + 3) * 4

# Floating point
3.14 * 2.0
10.5 / 2.0
`,
  },
  {
    id: "comparison",
    name: "Comparison",
    source: `# Comparison Operators
# Compare numbers with ==, !=, <, >, <=, >=

# Equality
5 == 5
5 != 3

# Ordering
10 > 5
3 < 7
5 <= 5
10 >= 10
`,
  },
  {
    id: "variables",
    name: "Variables",
    source: `# Variables with let
# Define and use variables

# Simple binding
let x = 42
x

# Multiple bindings
let a = 1
let b = 2
a + b

# Using expressions
let result = 10 * 5 + 3
result

# Variable reassignment
let counter = 0
let counter = counter + 1
let counter = counter + 1
counter
`,
  },
  {
    id: "functions",
    name: "Functions",
    source: `# Functions
# Define and call functions

# Simple function
fn double x = x * 2
double 5

# Multi-parameter function
fn add x y = x + y
add 3 7

# Function with closure
let outer = 100
fn capture = outer + 1
capture
`,
  },
  {
    id: "measures",
    name: "Measures",
    source: `# Units of Measure
# Define and use physical units

# Define base units
measure meter
measure second

# Use base units
10meter
5second

# Derived units
measure kilometer = meter 1000
2kilometer

# Convert between units
let distance = 5000meter
let km = 5kilometer
distance
km

# Unit arithmetic
let speed = 100meter / 10second
speed
`,
  },
  {
    id: "lists",
    name: "Lists",
    source: `# Lists
# Collection of values in square brackets

# Empty list
[]

# Simple list of integers
[1, 2, 3, 4, 5]

# Assign to variable
let numbers = [10, 20, 30]
numbers

# List with expressions
let x = 5
let y = 10
[x, y, x + y, x * y]

# Nested lists
[[1, 2], [3, 4], [5, 6]]

# List with computed values
let a = 100
let b = 200
[[a, a * 2], [b, b / 2]]
`,
  },
  {
    id: "assertions",
    name: "Assertions",
    source: `# Assertions - Runtime Checks
# 
# The assert macro allows you to verify conditions at runtime
# and provides detailed error messages when assertions fail.

# Basic assertion - verifies a condition is true
let x = 5
assert x > 0

# Assertion with custom error message
let value = 42
assert value == 42 "value must be 42"

# Assertions are useful for validating function inputs and outputs
fn divide a b =
    assert b != 0 "cannot divide by zero"
    a / b

divide 10 2

# Assertions help catch errors early in development
let result = divide 10 2
assert result == 5 "expected result to be 5"
`,
  },
  {
    id: "enums",
    name: "Enums",
    source: `# Enums (Algebraic Data Types)
# Tagged unions with named variants

# Simple enum with record variants
enum Result {
  Ok = {
    value = Integer,
  },
  Error = {
    message = String,
  },
}

# Create enum values using variant constructors
let success = Result.Ok { value = 42 }
let failure = Result.Error { message = "Something went wrong" }

# Pattern matching on enums
match success
  Result.Ok { value } -> value
  Result.Error { message } -> 0

# Enum with different variant types
enum Shape {
  Circle = {
    radius = Float,
  },
  Rectangle = {
    width = Float,
    height = Float,
  },
  Triangle = {
    base = Float,
    height = Float,
  },
}

# Create shape values
let circle = Shape.Circle { radius = 5.0 }
let rect = Shape.Rectangle { width = 10.0, height = 20.0 }

# Calculate area using pattern matching
fn area shape =
  match shape
    Shape.Circle { radius } -> 3.14159 * radius * radius
    Shape.Rectangle { width, height } -> width * height
    Shape.Triangle { base, height } -> 0.5 * base * height

area circle
area rect

# Enum for optional values
enum Option {
  Some = {
    value = Integer,
  },
  None = {},
}

let some_value = Option.Some { value = 100 }
let no_value = Option.None {}

# Unwrap optional with default
fn unwrap_or option default =
  match option
    Option.Some { value } -> value
    Option.None {} -> default

unwrap_or some_value 0
unwrap_or no_value -1
`,
  },
];
