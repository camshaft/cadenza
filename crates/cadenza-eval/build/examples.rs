pub struct Example {
    pub name: String,
    pub id: String,
    pub display_name: String,
    pub src: String,
}

impl Example {
    fn load(subdir: &str) -> Box<[Example]> {
        let dir = format!("{}/{}/", env!("CARGO_MANIFEST_DIR"), subdir);
        let mut examples = Vec::new();
        let Ok(entries) = std::fs::read_dir(&dir) else {
            return examples.into();
        };
        for entry in entries {
            let entry = entry.unwrap();
            let path = entry.path();
            // Skip directories
            if path.is_dir() {
                continue;
            }
            if path.extension().is_none_or(|ext| ext != "cdz") {
                continue;
            }

            let file_name = path.file_stem().unwrap().to_str().unwrap();
            // Only process files that start with "example-"
            if !file_name.starts_with("example-") {
                continue;
            }

            // Extract the display name from the file name
            // Format: example-##-name -> Name
            let parts: Vec<&str> = file_name.split('-').collect();
            let display_name = if parts.len() >= 3 {
                // Skip "example" and the number, join the rest
                parts[2..]
                    .join(" ")
                    .split('_')
                    .map(|word| {
                        let mut chars = word.chars();
                        match chars.next() {
                            None => String::new(),
                            Some(first) => first.to_uppercase().chain(chars).collect(),
                        }
                    })
                    .collect::<Vec<_>>()
                    .join(" ")
            } else {
                file_name.replace("example-", "").replace('-', " ")
            };

            let id = parts[2..].join("-");

            let src = std::fs::read_to_string(&path).unwrap();
            examples.push(Example {
                name: file_name.to_string(),
                id,
                display_name,
                src,
            });
        }

        // Sort by file name to maintain the 01, 02, 03... ordering
        examples.sort_by(|a, b| a.name.cmp(&b.name));

        examples.into()
    }
}

/// Generate TypeScript file with examples
pub fn generate_typescript() -> String {
    let examples = Example::load("test-data");
    let mut out = String::new();

    macro_rules! w {
        ($($tt:tt)*) => {
            out.push_str(&format!($($tt)*));
            out.push('\n');
        };
    }

    w!("// This file is auto-generated by the build script.");
    w!("// Do not edit manually - changes will be overwritten.");
    w!("");
    w!("export interface Example {{");
    w!("  id: string;");
    w!("  name: string;");
    w!("  source: string;");
    w!("}}");
    w!("");
    w!("export const EXAMPLES: Example[] = [");

    for example in examples.iter() {
        w!("  {{");
        w!("    id: {:?},", example.id);
        w!("    name: {:?},", example.display_name);
        w!("    source: {},", escape_typescript_string(&example.src));
        w!("  }},");
    }

    w!("];");

    out
}

fn escape_typescript_string(s: &str) -> String {
    format!(
        "`{}`",
        s.replace('\\', "\\\\")
            .replace('`', "\\`")
            .replace("${", "\\${")
    )
}
